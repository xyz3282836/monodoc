# 数据库原理

## 时间复杂度

时间复杂度用来检验某个算法处理一定量的数据要花多长时间

大O符号是关于一个算法的最坏情况的

二分搜索法



合并排序 sort()函数内部原理

先拆分  次数log(N)

在一级一级排序 整体运算次数 N*log(N)



## 阵列、树、哈希表

三者是现在数据库的支柱

#### 阵列

二维阵列是最简单的数据结构等法规规定

![二维矩阵](http://ww2.sinaimg.cn/large/7cc829d3jw1f3drdpqm1oj20cl0apdhp.jpg)

#### 树和数据索引

binary search tree 

![二叉查找树/二叉搜索树/二叉排序树](http://jbcdn2.b0.upaiyun.com/2016/05/432222c9e8cd2d665083915430ae1a2e.png)

这个查询成本是O(log(N))

B树查找某个值 时间复杂度是O(log(N))，但是查找范围的时候将会变成O(N)

B树是每个节点都包含保存的信息(相关表的行位置)

为此B+树可以解决

B+树是B树的修订版，只有底层节点或者叶子节点才保存信息，其他节点用来指引到正确节点

![](http://jbcdn2.b0.upaiyun.com/2016/05/15c4b064af9ac7f357404a1b17ff1cae.png)

时间复杂度O(log(N))

在B+树中，插入和删除操作是 O(log(N)) 复杂度

mysql使用了B+树索引

#### 哈希表

![](http://ww1.sinaimg.cn/large/7cc829d3jw1f3drdsruaqj20hp09075r.jpg)

**如果有了好的哈希函数，在哈希表里搜索的时间复杂度是 O(1)**





> 数据版本控制和锁机制是两种不同的见解：**乐观锁和悲观锁**。两者各有利弊，完全取决于使用场景（读多还是写多）

