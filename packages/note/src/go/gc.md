# gc

## go 1.3 标记清楚法

Stw，扫描所有堆栈数据段，做出清除标记，然后清除，stw 结束

## go 1.5 三色标记法

stack

heap

data segment

以上存在的数据 gc 之前都标记为白色

开始追踪到的 root 节点都标记为灰色，表示追踪还没完成

基于某个节点的追踪完成，则把该节点标记为黑色，是存活数据

基于黑色节点追踪到的都会标记为灰色，灰色的继续追踪，直到只存在黑白两色

垃圾就是白色，有用数据就是黑色

缺点：过程中白色被黑色引用并且原本灰色引用这个白色关系破裂也就是**_1`白色被挂在黑色下（插入写）`_**同时**_2`灰色丢了该白色（删除写）`_**，就会出现 gc 清除了还需要存活的数据导致问题；满足 1 和 2 就会出现问题，只需要破坏一个就能解决这个问题。

为了解决这个缺点，有了强三色不变式和弱三色不变

强三色不变式破坏 1，强制不允许黑色引用白色

弱三色不变式破坏 2，黑色可以引用白色，但是白色需要存在链路上存在灰色对它的引用

所以三色标记中满足强或者弱三色不变之一，就可以解决问题，所有引入了屏障机制

## 屏障机制

### 插入写屏障 Dijistra(go1.7 之前使用这种屏障)

对象被引用时触发，heap 中启用插入屏障，栈不开启写屏障，代价太大

特点：heap 上，A(黑色)新增引用 B(白色)，**B 被标记为灰色**，`满足强三色不变式`破坏 1，这步没不足

缺点：stack 上，A(黑色)新增引用 B(白色)，**B 依然是白色**，但是准备回收白色前，**会重新扫描一次栈空间，并且此时是 stw**，保障引用关系不变这轮不变，从而 B 也会被标记为黑色，此处需要 10-100ms，这也是**不足**

### 删除写屏障 Yuasa

对象被删除时解除引用依赖触发，栈不开启写屏障，代价太大

特点：保证堆上指针连接断开时会被置灰

缺点：stack 黑色对象引用 heap 白色对象，此时删除引用，不会触发白色置灰，此时如果 heap 上另外一个对象新增对这个白色对象的引用，那么这个白色对象就是不能 gc 的对象，实际却被 gc 了，所以此处需要和插入写互补。

A(灰色)解除对于 B(白色或者灰色)的引用，那么**B 被标记为灰色**，满足弱三色不变式破坏 2，**这个时候如果没有其他黑色新增对于 B 的引用，实际 B 就是垃圾**，只能下一轮被 GC，这是**不足**，回收精度低，并且回收前也会进行 stw，做个快照保存，为下一轮 gc 做对比

## go 1.8 三色标记法+混合写屏障机制

### 混合写屏障机制 Hybrid

gc 开始时直接把 stack 上所有可达数据标记为黑色，无需重新扫描一次

gc 期间，任何 stack 新增数据都标记为黑色

栈上没有屏障机制，堆上启用混合写屏障

heap 上，被删除的数据（解除引用）被标记为灰色（沿用删除写屏障）

heap 上，被添加的数据（新增引用）被标记为灰色

满足弱三色不变式破坏 2

## 其他

在高层面上，GOGC 决定了 Go GC 在 CPU 和内存之间的取舍。

目标堆内存数量[19](https://taoshu.in/go/gc-guide.html#fn19)的定义如下：

Target heap memory = Live heap + (Live heap + GC roots) \* GOGC / 100

堆内存大小的目标值决定 GC 的频率：目标值越大，GC 等待开始下下次标记阶段的时间就越长；反之亦然。

这里的核心逻辑是**GOGC 翻倍会导致堆内存开销翻倍而且 GC CPU 成本大致下降一半**，反之亦然。

GOGC 可以通过`GOGC`环境变量来配置（所以 Go 程序都会识别），也可以通过`runtime/debug`包的[`SetGCPercent`](https://pkg.go.dev/runtime/debug#SetGCPercent)函数来设置。

注意，我们可以通过设置`GOGC=off`或者调用`SetGCPercent(-1)` 完全禁用 GC 功能（在没有设置[内存上限](https://taoshu.in/go/gc-guide.html#内存限制)的情况下）。从概念上讲，该设置等价于将 GOGC 设置成无穷大，也就是把触发 GC 的内存上限设置为无限大。
