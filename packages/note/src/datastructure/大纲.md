# 数据结构

主要分为物理结构和逻辑结构
物理结构是内存中实实在在的存储结构
逻辑结构是抽象概念，依赖物理结构

## 物理结构

顺序存储结构：数组
链式存储结构：链表
数组和链表都是线性数据结构

## 逻辑结构

线性结构：顺序表，栈，队列
非线性结构：树，图

## 栈

First In Last Out 简称 FILO
可以用数组实现，也可以用链表实现

## 队列

First In First Out 简称 FIFO
可以用数组实现，也可以用链表实现

## 散列表

散列表也叫做哈希表(hash table)
本质上是个数组
会有哈希冲突，主要有两种开发寻址法(java ThreadLocal)，和链表法(java 集合类 HashMap)
链表法

### 哈希函数

将 key 和数组下标转换，这个过程就是哈希函数

### 扩容

基于数组实现，需要扩容
jdk8 会把 entry 的链表转换为红黑树这种结构，提升查找和插入效率

## 树

root 根节点，leaf 叶子节点，parent 父节点，child 孩子节点，sibling 兄弟节点，树的最大层级称为高度或者深度

### 二叉树

每个节点最多两个孩子节点
有两种特殊形式，一种是满二叉树，一种是完全二叉树

#### 满二叉树

都是完全的左右孩子节点

#### 完全二叉树

需要：1~h-1 层节点数最大(满二叉树)；h 层左连续

二叉树可以用数组和链式存储结构两种物理存储结构实现

稀疏的二叉树使用数组来实现是非常浪费空间的，不过二叉堆也就是一种特殊的完全二叉树最适合用数组来实现

#### 应用

查找：二叉查找树(二叉排序树) bst，查找的时间复杂度 O(logn)

左子树所有节点的值均小于根节点的值，右子树所有节点的值均大于根节点的值

### 二叉树的遍历

二叉树是非线性结构，但是遍历本身是个线性操作，所以需要吧非线性关联节点转化成一个线性序列，所以才有了不同的遍历顺序

1. 前序遍历：根，左，右
2. 中序遍历：左，根，右
3. 后序遍历：左，右，根
4. 层序遍历

前三种是**深度优先**遍历，绝大多数是用**递归**来遍历，也可以使用栈来实现，因为递归和栈都具有回溯的特性。

最后一种是**广度优先**遍历，通过**队列**来实现，

二叉树的构建方法很多，可以把一个线性链表转换为非线性二叉树，链表节点的顺序就是二叉树前序遍历的顺序，链表空值代表左右孩子为空的情况

### 二叉堆

本质是一种完全二叉树，分为两个类型：最大堆和最小堆

插入节点：插入到最后一个位置，进行上浮 O(logn)

删除节点：将最后一个节点临时补到原本删除的位置 O(logn)

构建二叉堆：把一个无序的完全二叉树调整为二叉堆，实际从 h-1 层开始调整 O(n)

二叉堆虽然是个完全二叉树，但是他的存储是顺序存储，而不是链式存储，就是使用数组实现的

二叉堆是实现**堆排序**及**优先队列**的基础

### 优先队列

普通队列就是先进先出

最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队，最小队列同样

所以使用二叉堆来实现优先队列

## 排序算法

时间复杂度为 O(n^2^)的排序

冒泡，选择，插入

冒泡主要交换

时间复杂度为 O(nlogn)的排序

希尔，快速，归并，堆

快排采用分治法，选一个基准元素，比大，比小各一边

基数排序，桶排序，归并排序

### 冒泡算法

是稳定排序（相同元素，位置是否发生变化）

可以优化一：记录一个变量是否有交换元素，没有说明顺序已经 ok

可以优化二：记录一个变量标记最后交换的位置，这个未知后面就都是最终有序的，每轮就不需要去比较后面有序的元素了

鸡尾酒排序：冒泡的升级版，先左边开始冒泡，然后右边开始冒泡，这样中间部分有序的就不需要冒泡了，减少轮数（鸡尾酒排序已经使用了优化一了，可以在加上优化二，效果更加好）

### 选择排序

不稳定排序

每次取一个剩下最大（小）的元素放到一边，和插入排序相反

两边，一边有序，一边无序，无序的一边每次取一个最大（小）的元素放到有序的一边

### 插入排序

稳定排序

每次取一个元素放到已经排好序的组里进行一轮比较排序

两边，一边有序，一边无序，无序的一边每次取一个的元素放到有序的一边，和有序的进行重新排序

如果初始有序程度高，那么插入排序就越快，选择排序则和初始顺序无关

### 希尔排序

不稳定排序

插入排序的升级版，gap1=len/2,gap2=gap1/2,...,1，每轮相连 gap 个做插入排序

### 快速排序算法

分治法，每一轮挑选一个基准元素，让比它大的移到一边，比它小移到另一边，把数列拆成两个部分

平均时间复杂度 O(nlogn)，不稳定排序，最坏的时间复杂度是 O(n^2^)

双边循环法：right，left 从两边向中间

单边循环法：mark 作为一部小和一部分大的边界

都是递归去实现

绝大多数的递归逻辑，都可以用栈的方式替代

### 归并排序

### 堆排序

因为堆顶是个最小大元素，每次获取堆顶元素都是按照大小依次排序的

平均时间复杂度和最坏空间复杂度都是 O(nlogn)

新增，删除堆顶元素的时间复杂度是 O(logn)

构建大小堆的时间负责度是 O(n)

推导：S=1×2^h-1^+2×2^h-2^+3×2^h-3^+...+(h-1)2^1^+h×2^0^

2S=1×2^h^+2×2^h-1^+3×2^h-2^+...+h×2^1^

2S-S=2^h^+2^h-1^+...+2^1^+2^0^-2^0^-h×2^0^

S=2^h+1^-1-1-h=2^h+1^-2-h

h=logn

S=2n-2-logn=O(n)

堆排序两个过程

1.构建堆 O(n)

2.逐个取出顶元素 (n-1)×logn

O(n)+(n-1)logn=O(nlogn)

堆排序和快速排序都是不稳定的，平均时间复杂度都是 O(nlogn)

快速排序最换时间复杂度是 n^2^,而堆排序的最坏时间复杂度稳定在 O(nlogn)

### 基数排序

### 计数排序

### 桶排序

一种线性时间排序算法
